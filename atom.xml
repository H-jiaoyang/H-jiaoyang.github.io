<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://H-jiaoyang.github.io</id>
    <title>connais</title>
    <updated>2024-02-03T03:32:03.890Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://H-jiaoyang.github.io"/>
    <link rel="self" href="https://H-jiaoyang.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://H-jiaoyang.github.io/images/avatar.png</logo>
    <icon>https://H-jiaoyang.github.io/favicon.ico</icon>
    <rights>All rights reserved 2024, connais</rights>
    <entry>
        <title type="html"><![CDATA[逻辑综合优化]]></title>
        <id>https://H-jiaoyang.github.io/post/luo-ji-zong-he-you-hua/</id>
        <link href="https://H-jiaoyang.github.io/post/luo-ji-zong-he-you-hua/">
        </link>
        <updated>2024-02-03T02:57:39.000Z</updated>
        <content type="html"><![CDATA[<p>DC综合优化文章:<br>
• https://blog.csdn.net/qq_21842097/article/details/111769765<br>
• DC优化的常用方法 | 大卫的博客园 (david-luge.cn)<br>
• 综合优化策略介绍-Design Compiler（五）_set_boundary_optimization-CSDN博客<br>
• 第十七课：DC优化技术_dc retime 参数-CSDN博客<br>
• Design Compiler工具学习笔记（5）_design compiler 获取元素-CSDN博客<br>
• 数字逻辑综合工具-DC-06——综合优化过程_compile_ultra -gate_clock-CSDN博客<br>
• 数字逻辑综合工具实践-DC-07 ——综合优化（二）和RTL coding 和DFT-CSDN博客<br>
对时序路径、工作环境、设计规则等约束完成之后，DC就可以进行综合、优化时序了，DC在优化过程中主要的策略将在下面进行说明。然而，当普通模式下不能进行优化的，就需要我们进行编写脚本来改进DC的优化来达到时序要求。<br>
DC进行优化的目的是权衡timing和area约束，满足用户对功能、时序和面积的要求。<br>
DC 的优化过程需要基于设计者对 Design 的约束，其中约束又分为两类，Design Rule Constraint（DRC）和 Optimization Constraint，其中 DRC 的优先级较高（优先保证满足 DRC）。<br>
• Design Rule Constraint：Transition，Fanout，Capacitance；<br>
• Optimization Constraint：Timing，Area；<br>
<img src="https://H-jiaoyang.github.io/post-images/1706929899136.png" alt="" loading="lazy"></p>
<p>DC优化有很多策略，包括对数据通道的优化，对状态机的优化，对布尔逻辑的优化等。<br>
<img src="https://H-jiaoyang.github.io/post-images/1706929909639.png" alt="" loading="lazy"></p>
<p>Compile_Ultra默认优化的三个层面：架构层优化、逻辑/GTECH网表优化、门级网表优化；目的是为了在满足时序约束的前提下使芯片面积最小，可以引入一些外部的高性能优化算法；<br>
<img src="https://H-jiaoyang.github.io/post-images/1706929919670.png" alt="" loading="lazy"></p>
<p>一般来说，采用关键路径重新综合(关键路径就是延时最大的路径)的方法，在第一次mapping后，会发现一些路径存在时序违规，对于这些违规的路径，DC会重新回到logic/GTECH level优化，然后再进行二次mapping，不断重复，直到完成或者实在不行就会停止；<br>
<img src="https://H-jiaoyang.github.io/post-images/1706929931133.png" alt="" loading="lazy"></p>
<p>一、Automatic Ungrouping and Boundary optimization<br>
Automatic Ungrouping：<br>
<img src="https://H-jiaoyang.github.io/post-images/1706929943791.png" alt="" loading="lazy"></p>
<p>compile默认不打散，compile_ultra会自动将模块的设计层次结构打散，打散后只能看到top层和具体实现；<br>
常见指令如下：compile_ultra，compile -auto_ungroup。<br>
compile会提供两种策略，包括：delay-based auto-ungrouping， area-based auto-ungrouping。<br>
Ungrouping 就是取消设计中的层次结构，将小模块打散直接合并到大模块中，移除了层次结构的边界，可以让 DC 工具 “放开手脚”，可以通过减少逻辑级数来改善时序，并通过逻辑资源共享来降低面积。<br>
例如：<br>
set compile_ultre_ungroup_dw true ;#允许打散，取消desigware层次。<br>
也就是说，调用的一个加法器和一个乘法器，本来他们是以IP核的形式，或者说是以模块的形式进行综合的，但是设置了上面那么变量之后，综合后那个模块的界面就没有了。全部ungroup打散后，没有boundary，一般功能是不会影响的，LEC来保证。但是function层次就没有了，比如对网表做一些verification，如STA时一些重要的点可能找不到了，如果还要debug的话几乎做不下去。也就是说不打散较好。<br>
为了使设计的结果最优化，建议将compile_ultra命令和DesignWare library一起使用。<br>
• set_ungroup &lt;reference_or_cells&gt; false  ; #禁止cell打散<br>
• set_app_var compile_ultra_ungroup_dw false  ；#禁止打散，使用designware层次<br>
• compile_ultra -no autoungroup ;#全部都不打散<br>
<img src="https://H-jiaoyang.github.io/post-images/1706929959125.png" alt="" loading="lazy"></p>
<p>Boundary optimization边界优化:<br>
compile_ultra中，是默认开启边界优化的，在编译时，Design Compiler会对传输常数，没有连接的引脚和补码信息进行优化，也就是说边界优化会把边界引脚一些固定的电平，固定的逻辑进行优化。但是在formility（形式验证），需要告诉formility电路结构发生了改变。这个改变存放在DC的生成文件里。这种边界优化是会影响网表结构的<br>
<img src="https://H-jiaoyang.github.io/post-images/1706929974840.png" alt="" loading="lazy"></p>
<p>set_boundary_optimization&lt;cells_designs&gt; false #可设置某些cell不做边界优化（该模块为公用模块/或者以后有ECO需求，可能会用到一些接口）<br>
compile_ultra -no_boundary #批量设置不进行边界优化</p>
<p>综合阶段利用auto-ungroup和boundary timing优化修复。大部分情况下我们是不打开这两个选项的，但是它确实能够得到一个相对较好的timing结果。如果采用auto-ungroup和boundary timing优化，design中的层次可能会被打散，不保留原来的hierarchical。cell的层次被打散后，一方面后端实现时不好分析模块的逻辑关系，另外一方面是最重要的，也是最致命的，就是万一将来要在某个地方做功能上的ECO（不幸边界被优化了），那个时候就特别郁闷了，eco难度会很大。所以对于比较成熟的模块，其实完全可以打开这两个选项的。</p>
<p>二、High-level optimization and datapath optimization<br>
<img src="https://H-jiaoyang.github.io/post-images/1706929996654.png" alt="" loading="lazy"><br>
<img src="https://H-jiaoyang.github.io/post-images/1706930007271.png" alt="" loading="lazy"></p>
<p>三、adaptive retiming and timing<br>
adaptive retiming：<br>
Adaptive Retiming（自适应时序调整）是 DC 工具中的一种优化技术，旨在调整电路中寄存器的位置以改善电路性能。它可以动态地适应电路中的性能需求，以达到设计目标。这对于高性能数字电路设计非常重要，尤其是在面临时序违规、时序紧迫性和电路性能优化的情况下。如果在逻辑综合过程中发现设计的流水线划分不平衡，就可以使用retiming策略，在时序路径上前后移动寄存器，以提高电路的时序性能，如果没有违例的路径，则可用来减少寄存器的数量。<br>
retiming 策略有两种，分别是 Backward Move 和 Forward Move：<br>
<img src="https://H-jiaoyang.github.io/post-images/1706930019284.png" alt="" loading="lazy"></p>
<p>由上图所示，retiming可能会对面积产生影响，则如果有违例的路径，则调整寄存器的位置；如果没有违例的路径，则可以用来减少寄存器的数量。通过adaptive retiming功能，再保证局部功能不变的前提下，可以进行寄存器位置的移动、分割及合并，从而改变在局部改变关键路径时序违规；<br>
<img src="https://H-jiaoyang.github.io/post-images/1706930033813.png" alt="" loading="lazy"></p>
<p>DC在移动寄存器的优化中，只能对有相同约束的寄存器进行调整，如果两个寄存器约束不同，则不能一起移动。移动后的寄存器在网表中的名字通常带有一个R的前缀和一个系列号，如果想知道工具有没有进行retiming，可以在svf文件中查看有没有这种重命名的寄存器。<br>
retiming的策略不能和compile_ultra的以下option一起使用：-incremental -top -only_design_rule<br>
compile_ultra -retime #把时序不满足部分组合逻辑转移到有余量地方，前一级就得到很大的改善。后面的violation可以通过把时钟稍微往后挪一点来改善掉。<br>
<img src="https://H-jiaoyang.github.io/post-images/1706930053060.png" alt="" loading="lazy"></p>
<p>#Retiming的基本思想：这几种结构在功能和时序上是等效的</p>
<p>如果不希望这种retiming发生在一些特定的寄存器或者design中，可以通过命令设置<br>
<img src="https://H-jiaoyang.github.io/post-images/1706930075695.png" alt="" loading="lazy"></p>
<p>timing：<br>
寄存器复制：如图所示，意思就是当某个寄存器后面的fanout太多时，允许工具自动复制控制寄存器的个数，从而降低每个控制寄存器的fanout，就和前面说的负载分割及组合逻辑复制类似；<br>
compile_ultra -timing #采用register replication的方法修复critical path时序<br>
<img src="https://H-jiaoyang.github.io/post-images/1706930088308.png" alt="" loading="lazy"></p>
<p>四、high-effort compile<br>
high-effort compile能够让DC更加努力地达到所约束地目标，该措施在关键路径上进行重新综合，同时对关键路径周围地逻辑进行了restructure和remap。对时序做最好的优化，会把时序的优先级提升到超过DRC（Design Rule Check）的优先级，DRC是工艺厂商的要求，不满足DRC可能会出错。<br>
high-effort指令有两种：<br>
• compile ultra command：附带两个option，这两个option分别包含一些脚本，提供额外地时序和面积地优化。option为：area_high_effort_script option和timing_high_effort_script option。<br>
• compile command：附带一个option，map_effort -high option。</p>
<p><img src="https://H-jiaoyang.github.io/post-images/1706930106619.png" alt="" loading="lazy"><br>
High effort对关键路径地优化包括逻辑复制（Logic Duplication）和映射为大扇入的门单元（Mapping to Wide_Fanin Gates）。<br>
<img src="https://H-jiaoyang.github.io/post-images/1706930120384.png" alt="" loading="lazy"></p>
<p>此外，incremental指令也可以提高电路优化的性能。如果电路在compile之后不满足约束，通过incremental也许能够达到要求的结果。incremental指令只进行门级的优化，而不是逻辑功能级，会导致大量的计算时间，但是对于将最差的负slack减为0，这是最有效的办法。<br>
为了在使用incremental指令时，减少DC的运算时间，可以将满足时序要求的模块设置为dont_touch属性。<br>
dont_touch noncritical_blocks<br>
对于有很多违例逻辑模块的设计，通常incremental最有效。<br>
compile -map_effort high -incremental_mapping</p>
<p>五、creating group path<br>
默认情况下，DC根据不同的时钟划分path group。但如果设计中存在复杂的时钟，复杂的时序要求或者复杂的约束，用户可以将所关心的几条关键路径划分为一个path group，指定DC专注于改组路径的优化。也可以对不同的路径组设置不同的权重，权重值从0到100。<br>
<img src="https://H-jiaoyang.github.io/post-images/1706930136508.png" alt="" loading="lazy"><br>
默认情况下，DC只优化关键路径，即负SLACK最差的路径，如果在关键路径附近指定一个范围，那么DC会优化指定范围内的路径。由于优化的路径越多，DC运行时间越长。一般范围设定为时钟周期的10%。<br>
<img src="https://H-jiaoyang.github.io/post-images/1706930157510.png" alt="" loading="lazy"></p>
<p>六、gate-level optimizations<br>
<img src="https://H-jiaoyang.github.io/post-images/1706930173894.png" alt="" loading="lazy"><br>
Delay optimization<br>
在该阶段，DC 通过对关键路径进行遍历来修复 Delay 的违例。<br>
改善电路的 delay 主要有以下的思路：<br>
• 打散关键路径上的层次结构，并使能 boundary optimization；<br>
• 使用 Path Group 对关键路径进行分组，并在关键路径附近指定一个范围，那么 DC 就会优化指定范围之内的所有路径；<br>
• 在探索设计空间阶段，可以给设计的 delay 更高的优先级，探索设计能达到的最快速度（不一定满足 DRC）；<br>
• 对于扇出较大的 net 使用 balance_buffer 命令；</p>
<p>在 Delay optimization 阶段，有下面几种改善电路 delay 的方式：upsizing, load isolation and splitting.<br>
“upsize” 是一种优化技术，旨在通过增大某些逻辑门的规模来提高电路性能。将电路中的某些标准逻辑门替换成面积更大的逻辑门可以增强逻辑门的驱动能力，从而获得更低的传输延迟，但它会导致面积和功耗的增加，因此使用时需要注意。<br>
<img src="https://H-jiaoyang.github.io/post-images/1706930188921.png" alt="" loading="lazy"></p>
<p>load isolation and splitting 旨在减小逻辑门的输出负载，来改善电路的性能指标。主要思想是将逻辑门的输出与输入负载隔离开，以减小输出驱动电流。这可以通过以下方式实现：1. 在输出端插入缓冲器，以减小输出电路的负载电容。这可以降低输出延迟，提高电路的时序性能。同时，缓冲器还可以提供更高的输出驱动能力；2. 重新组织电路逻辑，将一些逻辑元素拆分为多个阶段，以减小每个阶段的输出负载，这通常需要在逻辑层面进行重新设计。（面积换速度）<br>
<img src="https://H-jiaoyang.github.io/post-images/1706930198966.png" alt="" loading="lazy"></p>
<p>需要注意的是，DC 在此阶段已经开始考虑 DRC。同样条件下，会选择 DRC 代价最小的方案。</p>
<p>Design Rule Fixing<br>
DC 主要通过 Resize 或者插 Buffer 等方式来满足 DRC 约束；<br>
一般不会影响时序和面积结果，但必要时会导致 optimization consrtaints 违例；</p>
<p>Area Recovery<br>
不会引起 DRC 和 Delay 的违例，一般只是对非关键路径进行优化，优化方式包括 Cell DownSize 和 buffer and inverter cleanup；<br>
如果没有设置面积约束，那么优化幅度会很小；</p>
<p>七、Pipeline/Register Retiming<br>
Pipeline/Register Retiming: 多级流水线重新调整时序，与adaptive retiming类似，也是通过移动/合并/拆分寄存器来实现的；但不同的是，register retiming 是作用在整个纯的流水线design 模块当中的，中间不能有任何的控制部分；adaptive retiming则可以作用在非流水线设计的寄存器部分；二者可以同时并行使用；<br>
pipeline并不是拆的越散越好。<br>
代价：DFF的面积和初始化的延迟。<br>
<img src="https://H-jiaoyang.github.io/post-images/1706930233683.png" alt="" loading="lazy"></p>
<p>专门对流水线寄存器做优化的选项（必须要用Compile_Ultra）<br>
<img src="https://H-jiaoyang.github.io/post-images/1706930254698.png" alt="" loading="lazy"><br>
<img src="https://H-jiaoyang.github.io/post-images/1706930271423.png" alt="" loading="lazy"></p>
<p>调整了之后，寄存器会重新命名，S#表示是流水线的第多少级<br>
这些调整信息都会放入default.svf文件，交给后端的Formality，做形式验证。<br>
当我们打开了register retiming后，工具就可以自动将后面的三拍作为多级流水线设计而加入到前面的复杂组合逻辑中，而不用人为修改rtl代码，这种工具自动插入的流水线位置会非常精确均匀，人工改代码是难以实现的；</p>
<p>注意事项<br>
<img src="https://H-jiaoyang.github.io/post-images/1706930284704.png" alt="" loading="lazy"></p>
<p>我们一般在实际操作时，通常最后一个寄存器是作为output的，为了不影响其他模块的时序，对最后一个寄存器是不进行register retiming的，可以通过上述命令告诉工具不要动最后一个寄存器；</p>
<p>八、verifying functional equivalence<br>
<img src="https://H-jiaoyang.github.io/post-images/1706930294386.png" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[DC综合建立时间违例修改记录]]></title>
        <id>https://H-jiaoyang.github.io/post/dc-zong-he-jian-li-shi-jian-wei-li-xiu-gai-ji-lu/</id>
        <link href="https://H-jiaoyang.github.io/post/dc-zong-he-jian-li-shi-jian-wei-li-xiu-gai-ji-lu/">
        </link>
        <updated>2024-01-31T08:08:43.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1dc的综合环境">1.DC的综合环境：</h2>
<h3 id="clk500m时钟">CLK：500M时钟</h3>
<h3 id="lib工艺库tsmc-tcb018g3d3wcdbwccom-operation-conditions">LIB工艺库：TSMC tcb018g3d3wc.db(WCCOM operation conditions)</h3>
<h3 id="运行环境dc_shell采用wire-load-model估算delay">运行环境：dc_shell，采用wire load model估算delay</h3>
<h3 id="时钟的约束部分">时钟的约束部分：</h3>
<figure data-type="image" tabindex="1"><img src="https://H-jiaoyang.github.io/post-images/1706688647471.png" alt="" loading="lazy"></figure>
<h2 id="2修改过程">2.修改过程</h2>
<h3 id="21-最严重的违例">2.1 最严重的违例</h3>
<figure data-type="image" tabindex="2"><img src="https://H-jiaoyang.github.io/post-images/1706688668173.png" alt="" loading="lazy"></figure>
<h3 id="tset-up违例过大时序报告中看到该条路经上插入了过多的或门一级级的或门连接在起的组合逻辑门电路延时太大远超出时钟周期数倍此时通过优化约束带来的效果不明显重新修改rtl代码">Tset up违例过大，时序报告中看到该条路经上插入了过多的或门，一级级的或门连接在起的组合逻辑门电路延时太大，远超出时钟周期数倍，此时通过优化约束带来的效果不明显，重新修改RTL代码。</h3>
<h3 id="对应的问题代码部分组合逻辑中使用了if-else语句判断并且if中的组合逻辑判断的复杂的关系了组合逻辑长链带来严重的delay也是为什么在gui中查看schematic中会有很多的或门">对应的问题代码部分：组合逻辑中使用了if else语句判断，并且if中的组合逻辑判断的复杂的关系了组合逻辑长链带来严重的delay，也是为什么在gui中查看schematic中会有很多的或门。	<img src="https://H-jiaoyang.github.io/post-images/1706688724711.png" alt="" loading="lazy"></h3>
<h3 id="修改后的代码部分将if-else语句换为case避免因为if-else语句生成的电路的优先级原因导致的delay同时使用寄存器输出结果优化此处的时序通过修改后避免了过长的组合逻辑链减少了违例">修改后的代码部分：将if else语句换为case，避免因为if else语句生成的电路的优先级原因导致的delay，同时使用寄存器输出结果，优化此处的时序，通过修改后避免了过长的组合逻辑链，减少了违例。</h3>
<figure data-type="image" tabindex="3"><img src="https://H-jiaoyang.github.io/post-images/1706688748005.png" alt="" loading="lazy"></figure>
<h3 id="22-其他的违例">2.2 其他的违例</h3>
<h3 id="在本次设计比较严重的违例中大多是因为在rtl编写的时候没有考虑到if-else的优先级组合逻辑的运算较为复杂导致的因为采用的是18的工艺相对来说门电路的延时会比较大之前虽然测试了一些模块能通过fpga的布局布线但是实际的工艺延时较大rtl需要考虑到更加优化的写法">在本次设计比较严重的违例中，大多是因为在RTL编写的时候，没有考虑到if else的优先级组合逻辑的运算较为复杂导致的，因为采用的是.18的工艺，相对来说门电路的延时会比较大，之前虽然测试了一些模块，能通过FPGA的布局布线，但是实际的工艺延时较大，RTL需要考虑到更加优化的写法。</h3>
<figure data-type="image" tabindex="4"><img src="https://H-jiaoyang.github.io/post-images/1706688780569.png" alt="" loading="lazy"></figure>
<h3 id="此处展示的代码的组合逻辑就是导致违例过大的原因组合逻辑运算复杂">此处展示的代码的组合逻辑就是导致违例过大的原因：组合逻辑运算复杂</h3>
<figure data-type="image" tabindex="5"><img src="https://H-jiaoyang.github.io/post-images/1706688802941.png" alt="" loading="lazy"></figure>
<h3 id="同时后续在状态机中使用了这些复杂组合逻辑产生的信号进行跳转导致状态机部分违例较大同样的通过修改约束条件影响很小于是开始修改了复杂的组合逻辑尝试着简化组合逻辑和pipeline的方法来优化时序">同时后续在状态机中使用了这些复杂组合逻辑产生的信号进行跳转，导致状态机部分违例较大，同样的通过修改约束条件影响很小，于是开始修改了复杂的组合逻辑，尝试着简化组合逻辑和pipeline的方法来优化时序。</h3>
<figure data-type="image" tabindex="6"><img src="https://H-jiaoyang.github.io/post-images/1706688832892.png" alt="" loading="lazy"></figure>
<h3 id="上图展示的idle_flag信号修改前是通过三条不同的判断逻辑相或得到的在时序报告中以及dc-gui中查看相应的schematic都发现是因为组合逻辑门电路的长链所导致的采取的方法是将所有的判断条件拆开各自独立的判断通过寄存器输出拆开后的判断结果再经过对应的简单编码规则来输出信号">上图展示的idle_flag信号，修改前是通过三条不同的判断逻辑相或得到的，在时序报告中以及dc gui中查看相应的schematic都发现是因为组合逻辑门电路的长链所导致的，采取的方法是将所有的判断条件拆开，各自独立的判断，通过寄存器输出拆开后的判断结果，再经过对应的简单编码规则来输出信号。</h3>
<h3 id="还有采用assign判断的组合逻辑在判断条件里看似简单的运算xxx_cnt-26可能会有比较大的delay将括号里的组合判断通过reg输出插入寄存器优化">还有采用assign判断的组合逻辑，在判断条件里看似简单的运算（xxx_cnt == 26）可能会有比较大的delay，将括号里的组合判断通过reg输出，插入寄存器优化。</h3>
<p><img src="https://H-jiaoyang.github.io/post-images/1706688859027.png" alt="" loading="lazy"><br>
<img src="https://H-jiaoyang.github.io/post-images/1706688876722.png" alt="" loading="lazy"><br>
<img src="https://H-jiaoyang.github.io/post-images/1706688884914.png" alt="" loading="lazy"></p>
<h2 id="23-模块之间的胶合逻辑">2.3 模块之间的胶合逻辑</h2>
<h3 id="模块之间用组合逻辑连接在两个模块之间形成较长的组合逻辑将输出都通过寄存器输出-例如下图">模块之间用组合逻辑连接，在两个模块之间形成较长的组合逻辑，将输出都通过寄存器输出。例如下图：</h3>
<p><img src="https://H-jiaoyang.github.io/post-images/1706688908689.png" alt="" loading="lazy"><br>
<img src="https://H-jiaoyang.github.io/post-images/1706688931939.png" alt="" loading="lazy"></p>
<h3 id="修改组合逻辑较为臃肿的地方后时序依然还是存在违例后面采用了优化约束条件的方法降低了部分slack">修改组合逻辑较为臃肿的地方后，时序依然还是存在违例，后面采用了优化约束条件的方法降低了部分slack</h3>
<figure data-type="image" tabindex="7"><img src="https://H-jiaoyang.github.io/post-images/1706688954752.png" alt="" loading="lazy"></figure>
<h2 id="24-优化约束条件">2.4 优化约束条件</h2>
<h3 id="采用-incremental指令进行门级的优化">采用 -incremental指令进行门级的优化</h3>
<p><img src="https://H-jiaoyang.github.io/post-images/1706688980907.png" alt="" loading="lazy"><br>
<img src="https://H-jiaoyang.github.io/post-images/1706688989118.png" alt="" loading="lazy"></p>
<h3 id="自定义路径关键范围">自定义路径+关键范围</h3>
<p><img src="https://H-jiaoyang.github.io/post-images/1706689001935.png" alt="" loading="lazy"><br>
<img src="https://H-jiaoyang.github.io/post-images/1706689011509.png" alt="" loading="lazy"></p>
<h3 id="暂未使用的方法使用dc-topo模式优化brt等指令优化">暂未使用的方法：使用DC topo模式优化，BRT等指令优化。</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[FPGA学习第六章 I2C协议]]></title>
        <id>https://H-jiaoyang.github.io/post/di-liu-zhang-i2c-xie-yi/</id>
        <link href="https://H-jiaoyang.github.io/post/di-liu-zhang-i2c-xie-yi/">
        </link>
        <updated>2024-01-31T04:59:05.000Z</updated>
        <content type="html"><![CDATA[<p>😀第六章 I2C协议</p>
<p>第一节、IIC总线讲解<br>
1.基础概念：<br>
IIC(Inter Integrated Circuit，集成电路总线)是一种由 PHILIPS 公司开发的两线式串行总线，用于连接微控制器及其外围设备。它是由数据线 SDA(Serial DATA)和时钟 SCL(Serial CLK)构成的串行总线，可发送和接收数据。<br>
2. IIC特点：<br>
1.同步通信 (UART异步通信)<br>
2.有应答机制，通信更安全<br>
3.IIC是半双工，而不是全双工<br>
4.IIC总线多主多从<br>
5.速度：标准100Kbps、快速400Kbps、高速3.4Mbps<br>
3.工作方式：<br>
<img src="https://H-jiaoyang.github.io/post-images/1706681002733.png" alt=" " loading="lazy"><br>
<img src="https://H-jiaoyang.github.io/post-images/1706681016104.png" alt="" loading="lazy"><br>
4.协议组成:<br>
1.设备空闲状态：高电平 因为高电平可以检测设备的好坏<br>
2.起始位：时钟为高电平，数据线拉低<br>
3.停止位：时钟线为高电平，数据拉高<br>
4.数据输出：低电平改变状态<br>
5.应答：0有效应答，1无效应答<br>
6.时钟线SCL为高电平期间，数据线SDA上的数据必须保持稳定，只有时钟线SCL为低电平期间，数据     线SDA上的数据才 能改变<br>
<img src="https://H-jiaoyang.github.io/post-images/1706685602998.png" alt="" loading="lazy"><br>
5.协议相关知识点：<br>
1.IIC先发送高位的数据再发低位数据，一次发送8bit数据再加一个ACK位<br>
2.IIC的数据在下降沿改变，这样保证上升沿采样的数据是最稳定的<br>
3.IIC的应答机制是从机发送给主机的，IIC协议所有的操作由主机发起<br>
4.IIC的应答位为0电平是因为数据线的空闲状态是高电平状态<br>
6.上拉电阻：<br>
在设计IIC信号电路的时候会在SCL和SDA上加一个上拉电阻，主要原因就是IIC上的SDA和SCL的引脚都是开漏输出，只有一个mos管，不像推挽输出有两个。在芯片中，当一个输出级为漏极开路时，只能输出低电平或者高阻态，高阻态可以解为近似开路，此时输出的引脚电平不确定，可以被外部电平轻松改变。开漏输出可以理解为输出接一个开关，闭合时接低电平，断开时悬空。IIC支持多主多从，如果不开漏输出，会出现短路。<br>
通过开漏输出的特性，实现了线与的功能——当总线上有一个设备输出低电平时，整条总线处于低电平，这时的总线叫做占用。当输出端输出高阻态且没有其他设备占用总线时，上拉电阻拉高总线，总线呈现高电平状态。通过线与逻辑实现仲裁——总线上有其他设备将SDA置为0，线与后，SDA数据线的电平是0。仲裁时，哪个设备更早地将SDA拉低，谁就抢占了优先权。</p>
<p>第二节、AT24C64芯片阅读<br>
1.基础概念：<br>
AT24C64是EEPROM存储芯片，EEPROM的数据擦除相较Flash来说更加灵活，可以用来存储系统参数等数据量较小的场景，可以频繁的擦除数据。Flash写入数据之前要扇区擦除，常用于数据量较大的场景。<br>
AT24C64的容量为64kbit，256页，一页的大小为32Byte，通过IIC总线方式驱动数据的读写。<br>
写数据时芯片有一个忙碌的状态，等到读忙结束数据才能写入。<br>
2.读写操作：<br>
1.字节写操作：<br>
<img src="https://H-jiaoyang.github.io/post-images/1706685638646.png" alt="" loading="lazy"><br>
写字节操作先写入设备地址——设备地址即为硬件器件的地址，器件地址一共7bit，设备地址高位固定为1010，后三位地址由设备决定，最后一位是读写控制位（写--0、读--1）。主机发送地址后等待相应地址的从机的ACK响应信号。<br>
从机响应后主机发送写地址——数据存储的地址，写地址一共13bit，分成两次发送，因为一次IIC操作发送8bit一个字节的数据，第一次发送5bit，第二次发送8bit。<br>
发送完写地址后发送写入的数据，发送一次数据从机相应发送ACK信号。<br>
写完器件地址和读写控制位后总线释放为高阻态，从机发送ACK应答信号，此时相当于主机FPGA不进行控制，让从机来控制。<br>
2.页写操作：<br>
<img src="https://H-jiaoyang.github.io/post-images/1706685652965.png" alt="" loading="lazy"><br>
页写最多传输32byte的数据，当32byte的地址都被写完，数据会回到一页的开头覆盖之前的数据（地址滚转从当前页的最后一个字节到同一页的第一个字节），每次操作地址自动加一。<br>
3.随机读操作：<br>
<img src="https://H-jiaoyang.github.io/post-images/1706685660530.png" alt="" loading="lazy"><br>
随机读写有一个需写的操作，需写只写地址不写数据<br>
随机读写首先发送器件地址，然后发送存储数据的地址，写完存储地址后让总线重启发送开始位，然后发送设备地址开始读取数据<br>
第三节、Timgen画IIC波形图<br>
<img src="https://H-jiaoyang.github.io/post-images/1706685886672.png" alt="" loading="lazy"></p>
<p>第四节、IIC驱动+三态门控制编写<br>
1.三态门：<br>
在总线连接的结构上，总线上挂有多个设备，设备总线以高阻的形式连接。这样在设备不占用总线的时候自动释放总线，以方便其他设备获得总线的使用权。如果设备端口要挂在一个总线上，必须通过三态缓冲器，因为在一个总线上同时只能有一个端口做输出，这是其他的端口必须在高阻态，同时可以输入这个输出端口的数据。所以还需要有总线控制管理，访问到哪个端口，那个端口才可以转为输出状态，这是典型的三态门应用。<br>
IIC的SDA数据传输线是一个发送与接收共用的信号线（inout类型），那么就需要三态开漏模式去控制实现什么时候作为输出，什么时候作为输入，而且输出的时候不受输入的影响，输入的时候不受输出的影响。<br>
2.FPGA实现三态门：<br>
1.代码实现：<br>
<code>assign io_iic_sda = r_iic_sda_ctrl ? ro_iic_sda : 1'bz ;    //输出数据：CTRL信号拉高，ro_iic_sda的值赋值给io_sda_iic,数据从io口输出出去 assign w_iic_sda  = r_iic-sda_ctrl ? io_iic_sda : 1'b0 ;  //输入数据：CTRL信号拉低，io口为高阻态，从io_sda_iic输入的数据赋值给w_iic_sda </code></p>
<figure data-type="image" tabindex="1"><img src="https://H-jiaoyang.github.io/post-images/1706686103482.png" alt="" loading="lazy"></figure>
<pre><code>当FPGA向SDA数据线上写数据时，CTRL信号 = 1'b1; 则SDA = ro_iic_sda ？1‘bz :1’b0 ；
当FPGA向SDA数据线上写数据1时，SDA = 1‘bz（SDA的io口io_iic_sda为高阻态，从而避免影响w_iic_sda），又因为上拉电阻，所以外部器件得到的信号还是1；
当FPGA向SDA数据线上写数据0时，SDA = 1’b0（SDA的io口io_iic_sda为低电平），同时会将外接上拉电阻拉低，所以外部信号得到的还是0；
当FPGA不向SDA数据线上写数据时，CTRL信号 = 1‘b0；则SDA = 1’bz，此时三态门作为输入使用，w_iic_sda上的数据收到io_iic_sda上的数据影响，即等与外部器件输出的数据。
</code></pre>
<p>​</p>
<p>2.FPGA原语实现：<br>
在vivado中，连接的管脚的信号一般都会自动添加OBUF或IBUF。但是对于inout类型的接口，不会主动添加IOBUF因为in/out切换需要控制信号，需要用户自己分配好。<br>
在Language Template中能找到IOBUF的标准实例：<br>
<code>IOBUF #(    .DRIVE       (12), 			// Specify the output drive strength    .IBUF_LOW_PWR(&quot;TRUE&quot;),  		// Low Power - &quot;TRUE&quot;, High Performance = &quot;FALSE&quot;     .IOSTANDARD  (&quot;DEFAULT&quot;), 	// Specify the I/O standard    .SLEW        (&quot;SLOW&quot;) 		// Specify the output slew rate ) IOBUF_inst (    .O           (ro_iic_sda),     	// Buffer output    .IO          (io_iic_sda),   	// Buffer inout port (connect directly to top-level port)    .I           (w_iic_sda),     	// Buffer input    .T           (!r_iic_sda_ctrl) 	// 3-state enable input, high=input, low=output )</code><br>
原语中的O/I都是针对BUF来说的，不是针对管脚，务必注意。我们把 .IO() 端口当成pad管脚一侧，那么需要输出到io的内部信号填入到 .I()，通过OBUF缓冲输出到.IO()管脚；从.IO()管脚输入进来的信号经过IBUF缓冲到 .O()内部信号。输入信号想要正确，那么这个时候的OBUF必须是高阻z，也就是 .T()要有效。所以 .T() 填管脚input的使能条件，即让输出无效。</p>
<p>第五节、IIC驱动仿真调试<br>
1.</p>
]]></content>
    </entry>
</feed>